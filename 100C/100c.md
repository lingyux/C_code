# 100个经典的C程序

### 递归解决分鱼问题

#### 问题描述

A、B、C、D、E这5个人合伙夜间捕鱼，凌晨时都已经疲惫不堪，于是各自在河边的树丛中找地方睡着了。第二天日上三竿时，A第一个醒来，他将鱼平分为5份，把多余的一条扔回河中，然后拿着自己的一份回家去了；B第二个醒来，但不知道A已经拿走了一份鱼，于是他将剩下的鱼平分为5份，扔掉多余的一条，然后只拿走了自己的一份；接着C、D、E依次醒来，也都按同样的办法分鱼。问这5人至少合伙捕到多少条鱼？每个人醒来后所看到的鱼是多少条？

#### 问题分析

假设5个人合伙捕了x条鱼，则“A第一个醒来，他将鱼平分为5份，把多余的一条扔回河中，然后拿着自己的一份回家去了”之后，还剩下4(x-1)/5条鱼。

这里实际包含了一个隐含条件：假设Xn为第n(n=1、2、3、4、5)个人分鱼前鱼的总数，则(Xn-1)/5必须为正整数，否则不合题意。（Xn-1)/5为正整数即(X〜l)mod5=0必须成立。

又根据题意，应该有下面等式：
X4=4(X5-1)/5
X3=4(X4-1)/5
X2-4(X3-1)/5
X1=4(X2-1)/5

则一旦给定X5，就可以依次推算出X4、X3、X2和X1的值。要保证X5、X4、X3、X2和X1都满足条件(Xn-1)mod5=0，此时的X5则为5个人合伙捕到的鱼的总条数。显然，5个人合伙可能捕到的鱼的条数并不唯一，但题目中强调了 “至少”合伙捕到的鱼，此时题目的答案唯一。该问题可使用递归的方法求解。

#### 程序设计

在main()函数中构建一个不定次数的do-while循环。定义变量x表示5个人合伙可能捕到的鱼的条数，可以取x的最小值为6，让x值逐渐增加，x每一次取值，都增加5，直到找到一个符合问题要求的答案。由于题目中问“这5人至少合伙捕到多少条鱼”，而我找到的第一个x值就是5个人至少捕到的鱼的总条数。

通过这个循环，就可以对每一个的可能情况进行检查。当然，是通过调用分鱼的递归函数来进行检查的。

分鱼的递归函数如下：
fish()函数中包含了两个参数：n和x。n表示参与分鱼的人数，x表示n个人分鱼前鱼的总条数。这两个参数都是由main()函数中传递进来的。

根据前面的分析，当n=5时，(x-1)mod5 == 0必须成立，否则该x值不是满足题意的值，退出fish()函数，返回到main()函数，main()函数中再传递新的x值到fish中进行检验。如果(x-1)mod5 == 0条件成立，则要判断n=4时，(x-1)mod5=0条件是否成立，需要注意的是，此时的形参x是4个人分鱼前鱼的总条数，即f(5,x)递归调用f(4,(x-1)/5*4)。这样依次进行下去，直到n=1时，(x-1)mod5 == 0条件仍成立，则说明开始从main()函数中传递进来的x值是符合题意要求的一个值，可以逐层从递归函数中返回，每次返回值都为1，直至返回到main()函数。

#### 代码

`fish01.c`

#### 递推法

`fish02.c`

### C语言递归解决年龄问题

#### 问题描述

有5个人坐在一起，问第5个人多少岁，他说比第4个人大2岁。问第4个人多少岁，他说比第3个人大2岁。问第3人多少岁，他说比第2个人大2岁。问第2个人多少岁，他说比第1个人大2岁。最后问第1个人，他说他是10岁。编写程序，当输入第几个人时求出其对应的年龄。

#### 问题分析

该问题是一个递归问题。要求第5个人的年龄，必须先知道第4个人的年龄，显然第4个人的年龄也是未知的，但可以由第3个人的年龄推算出来。而想知道第3个人的年龄又必须先知道第2个人的年龄，第2个人的年龄则取决于第1个人的年龄。

#### 算法设计

`getAge.c`

### C语言马踏棋盘

#### 问题描述

国际象棋的棋盘为8×8的方格棋盘。现将“马”放在任意指定的方格中，按照“马”走棋的规则将“马”进行移动。要求每个方格只能进入一次，最终使得“马”走遍棋盘的64个方格。

编写一个C程序，实现马踏棋盘操作，要求用1〜64这64个数字标注马移动的路径，也就是按照求出的行走路线，将数字1，2，……64依次填入棋盘的方格中，并输出。

#### 问题分析

马的移动规则：

数字a放置在矩阵的（i，j）位置上，数字a+1只能放置在矩阵的（i-2，j+1），（i-1，j+2），（i+1，j+2），（i+2，j+1），（i+2，j-1），（i+1，j-2），（i-1，j-2），（i-2，j-1）之中的一个位置上。将矩阵填满并输出。

#### 

C代码

```c
#include <stdio.h>
#define X 8
#define Y 8
int chess[X][Y];

int nextxy(int *x, int *y, int count)  /*找到基于x,y位置的下一个可走的位置*/
{
    switch(count)
    {
        case 0:
            if(*x+2<=X-1 && *y-1>=0 && chess[*x+2][*y-1]==0)
            {
                *x=*x+2;
                *y=*y-1;
                return 1;
            }
            break;
        case 1:
            if(*x+2<=X-1 && *y+1<=Y-1 && chess[*x+2][*y+1]==0)
            {
                *x=*x+2;
                *y=*y+1;
                return 1;
            }
            break;
        case 2:
            if(*x+1<=X-1 && *y-2>=0 && chess[*x+1][*y-2]==0)
            {
                *x=*x+1;
                *y=*y-2;
                return 1;
            }
            break;
        case 3:
            if(*x+1<=X-1 && *y+2<=Y-1 && chess[*x+1][*y+2]==0)
            {
                *x=*x+1;
                *y=*y+2;
                return 1;
            }
            break;
        case 4:
            if(*x-2>=0 && *y-1>=0 && chess[*x-2][*y-1]==0)
            {
                *x=*x-2;
                *y=*y-1;
                return 1;
            }
            break;
        case 5:
            if(*x-2>=0 && *y+1<=Y-1 && chess[*x-2][*y+1]==0)
            {
                *x=*x-2;
                *y=*y+1;
                return 1;
            }
            break;
        case 6:
            if(*x-1>=0 && *y-2>=0 && chess[*x-1][*y-2]==0)
            {
                *x=*x-1;
                *y=*y-2;
                return 1;
            }
            break;
        case 7:
            if(*x-1>=0 && *y+2<=Y-1 && chess[*x-1][*y+2]==0)
            {
                *x=*x-1;
                *y=*y+2;
                return 1;
            }
            break;
        default:
            break;
    }
    return 0;
}

int TravelChessBoard(int x, int y, int tag)  /*深度优先搜索地"马踏棋盘"*/
{
    int x1=x, y1=y, flag=0, count=0;
    chess[x][y]=tag;
    if(tag == X*Y)
    {
        return 1;
    }
    flag=nextxy(&x1, &y1, count);
    while(flag==0 && count<7)
    {
        count=count+1;
        flag=nextxy(&x1, &y1, count);
    }
    while(flag)
    {
        if(TravelChessBoard(x1, y1, tag+1))
            return 1;
        x1=x;
        y1=y;
        count=count+1;
        flag=nextxy(&x1, &y1, count);  /*寻找下一个(x,y)*/
        while(flag==0 && count<7)
        {  /*循环地寻找下一个(x,y)*/
            count=count+1;
            flag=nextxy(&x1, &y1, count);
        }
    }
    if(flag == 0)
        chess[x][y]=0;
    return 0;
}
int main()
{
    int i, j;
    for(i=0; i<X; i++)
        for(j=0; j<Y; j++)
            chess[i][j]=0;
    if(TravelChessBoard(2, 0, 1))
    {
        for(i=0; i<X; i++)
        {
            for(j=0; j<Y; j++)
                printf("%-5d", chess[i][j]);
            printf("\n");
        }
        printf("The horse has travelled the chess borad\n");
    }
    else
        printf("The horse cannot travel the chess board\n");
    return 0;
}
```

### C语言在字符串的指定位置插入字符

#### 问题描述

在字符串的所有数字字符之前插入**$**符号

#### 问题分析

1.用字符串S拷贝出另一个字符串T，对字符串T进行从头至尾的扫描，对于非数字字符原样写入字符串S，对于数字字符，先写入一个**$**符号，再写入该数字字符，最后在字符串S的末尾加如结束标志。

2.对于字符串S进项从头至尾的扫描，当遇到数字字符时，从该字符至末尾，所有的字符右移一位，在该数字字符的原位置写入一个**$**。

```c
#include<stdio.h>

int fun(char* s)
{
	char t[80];
	int i,j;
	for(i = 0; s[i] ;i++) //将字符串S拷贝至T
		t[i] = s[i];
	t[i] = '\0';
	for(i = 0,j = 0; t[i] ; i++)
		if(t[i] >= '0'&&t[i] <= '9')
		{
			s[j++] = '$';
			s[j++] = t[i];
		}
		else
			s[j++] = t[i];
	s[j] = '\0';

	return 0;
}

int main()
{
	char s[80];
	printf("Enter a string:\n");
	scanf("%s",s);
	fun(s);
	printf("The result : %s\n",s);
	return 0;
}
```

### C语言删除*****号

#### 问题描述

现在有一串字符需要输入，规定输入的字符串中只包含字母和*号。请编写程序，实现以下功能：除了字符串前后的*号之外，将串中其他的*号全部删除。

例如，假设输入的字符串为`****A*BC*DEF*G********`，删除串中的*号后，字符串变为`****ABDEFG********`

#### 问题分析

该问题需要对字符串进行操作，而在C语言中没有专门的字符串变量，因此如果需要将一个字符串存放在变量中，则必须使用字符数组，即使用一个字符型数组来存放一个字符串，数组中的每一个元素存放一个字符。

#### 算法分析

设置两个指向字符的指针变量t和f。先使用循环语句让t指针指向字符串中最后一个字符，而f指针指向字符串中第一个字符；再判断t和f指向的字符是否为*****，如果为*****，则t指针自减，f指针自增，直到遇到第一个不是的字符为止。

再定义一个函数fun()用于删除字符串中的*****号，同时保留字符串前后的*****号。

```c
#include <stdio.h>
int fun(char *a, char *h, char *p)
{
    int i, j;
    /*删除指针h与p之间的所有“*”*/
    for(i=0,j=0; &h[i]<p; i++)
        if(h[i]!='*')
            h[j++]=h[i];
    /*将指针p至字符串尾部的所有字符前移*/
    for(i=0; p[i]; i++,j++)
        h[j]=p[i];
    h[j]='\0';  /*在字符串尾部添加结束标志*/
    return 0;
}
int main( )
{
    char s[81], *t, *f;
    printf("Enter a string :\n");
    gets(s);  /*输入字符串*/
    t=f=s;  /*用字符指针t、f指向串s*/
   
    while(*t)
        t++;
    t--;  /*将指针t定位到字符串中最后一个字符*/
    while(*t == '*')  /*指针t指向字符串中最后一个字符*/
        t--;
    while (*f == '*')  /*指针f指向字符串中第一个字符*/
        f++;
    fun(s, f, t);
    printf("The string after deleted:\n");  /*输出结果*/
    puts(s);
    return 0;
}
```

### 编写程序实现魔方阵

#### 问题描述

| 17   | 24   | 1    | 8    | 15   |
| ---- | ---- | ---- | ---- | ---- |
| 23   | 5    | 7    | 14   | 16   |
| 4    | 6    | 13   | 20   | 22   |
| 10   | 12   | 19   | 21   | 3    |
| 11   | 18   | 25   | 2    | 9    |

#### 问题分析

所谓“n-魔方阵”，指的是使用1〜n2共n2个自然数排列成一个n×n的方阵，其中n为奇数；该方阵的每行、每列及对角线元素之和都相等，并为一个只与n有关的常数，该常数为n×(n2+1)/2。

例如5-魔方阵，其第一行、第一列及主对角线上各元素之和如下：

- 第一行元素之和：17+24+1+8+15=65
- 第一列元素之和：17+23+4+10+11=65
- 主对角线上元素之和：17+5+13+21+9=65


而 n×(n2+1)/2=5×(52+1)/2=65 可以验证，5-魔方阵中其余各行、各列及副对角线上的元素之和也都为65。

假定阵列的行列下标都从0开始，则魔方阵的生成方法为：在第0行中间置1，对从2开始的其余n2-1个数依次按下列规则存放：
(1) 假定当前数的下标为(i，j)，则下一个数的放置位置为当前位置的右上方，即下标为(i-1，j+1)的位置。
(2) 如果当前数在第0行，即i-1小于0，则将下一个数放在最后一行的下一列上，即下标为(n-1，j+1)的位置。
(3) 如果当前数在最后一列上，即j+1大于n-1，则将下一个数放在上一行的第一列上，即下标为(i-1，0)的位置。
(4) 如果当前数是n的倍数，则将下一个数直接放在当前位置的正下方，即下标为(i+1，j）的位置。

#### 算法设计

在设计算法时釆用了下面一些方法：

- 定义array()函数，array()函数的根据输入的n值，生成并显示一个魔方阵，当发现n不是奇数时，就加1使之成为奇数。
- 使用动态内存分配与释放函数malloc()与free()，在程序执行过程中动态分配与释放内存，这样做的好处是使代码具有通用性，同时提高内存的使用率。


在分配内存时还要注意，由于一个整型数要占用两个内存，因此，如果魔方阵中要存放的数有max个，则分配内存时要分配2*max个单元，从而有malloc(max+max)。在malloc()函数中使用max+max而不是2*max是考虑了程序运行的性能。

显然应该使用二维数组来表示魔方阵，但虽然数组是二维形式的，而由于内存是一维线性的，因此在存取数组元素时，要将双下标转换为单个索引编号。在程序中直接定义了指针变量来指向数组空间，即使用malloc()函数分配的内存。

#### 代码

```c
#include<stdio.h>
#include<stdlib.h>

int array(int n)
{
    int i, j, no, num, max;
    int *mtrx;
    if(n%2 == 0)  /*n是偶数，则加1使其变为奇数*/
    {
        n=n+1;
    }
    max=n*n;
    mtrx=(int *)malloc(max+max);  /*为魔方阵分配内存*/
    mtrx[n/2]=1;  /* 将1存入数组*/
    i=0;  /*自然数1所在行*/
    j=n/2;  /*自然数1所在列*/
    /*从2开始确定每个数的存放位置*/
    for(num=2; num<=max; num++)
    {
        i=i-1;
        j=j+1;
        if((num-1)%n == 0)  /*当前数是n的倍数*/
        {
            i=i+2;
            j=j-1;
        }
        if(i<0)  /*当前数在第0行*/
        {
            i=n-1;
        }
        if(j>n-1)  /*当前数在最后一列，即n-1列*/
        {
            j=0;
        }
        no=i*n+j;  /*找到当前数在数组中的存放位置*/
        mtrx[no]=num;
    }
    /*打印生成的魔方阵*/
    printf("生成的%d-魔方阵为:",n);
    no=0;
    for(i=0; i<n; i++)
    {
        printf("\n");
        for(j=0; j<n; j++)
        {
            printf("%3d", mtrx[no]);
            no++;
        }
    }
    printf("\n");
    free(mtrx);
    return 0;
}

int main()
{
    int n;
    printf("请输入n值:\n");
    scanf("%d", &n);
    array(n);  /*调用array函数*/
    return 0;
}
```

### 渔夫分鱼

#### 问题描述

甲、乙、丙三位渔夫出海打鱼，他们随船带了21只箩筐。当晚返航时，他们发现有7筐装满了鱼，还有7筐装了半筐鱼，另外7筐则是空的，由于他们没有秤，只好通过目测认为7个满筐鱼的重量是相等的，7个半筐鱼的重量是相等的。在不将鱼倒出来的前提下,怎样将鱼平分为3份？

#### 问题分析

根据题意可以知道：每个人应分得七个箩筐，其中有3.5筐鱼。解决该问题可以采用一个3*3的数组，数组名为a来表示3个人分到的东西。其中每个人对应数组a的一行，数组的第0列放分到的鱼的整筐数，数组的第1列放分到的半筐数，数组的第2列放分到的空筐数。

又由题目可以推出：
(1) 数组的每行或每列的元素之和都为7。
(2) 对数组的行来说，满筐数加半筐数=3.5。
(3) 每个人所得的满筐数不能超过3筐。
(4) 每个人都必须至少有1个半筐，且半筐数一定为奇数。

对于找到的某种分鱼方案，3个人谁拿哪一份都是相同的，为了避免出现重复的分配方案，可以规定：第2个人的满筐数等于第1个人的满筐数；第2个人的半筐数大于等于第1个人的半筐数。

#### 代码：

```c
#include<stdio.h>

int a[3][3], count;

int main()
{
	int i, j, k, m, n, flag;
	printf("It exists possible distribtion plans:\n");
	for (i = 0; i <= 3; i++)
	{
		a[0][0] = i;
		for (j = i; j <= 7 - i && j <= 3; j++)
		{
			a[1][0] = j;
			if ((a[2][0] = 7 - j - a[0][0]) > 3)
				continue;
			if (a[2][0] < a[1][0])
				break;
			for (k = 1; k <= 5; k += 2)
			{
				a[0][1] = k;
				for (m = 1; m < 7 - k; m += 2)
				{
					a[1][1] = m;
					a[2][1] = 7 - k - m;
					for (flag = 1, n = 0; flag && n < 3; n++)
						if (a[n][0] + a[n][1] < 7 && a[n][0] * 2 + a[n][1] == 7)
							a[n][2] = 7 - a[n][0] - a[n][1];
						else
							flag = 0;
					if (flag)
					{
						++count;
						printf("No.%d Full basket Semi-basket empty\n", count );
						for (n = 0; n < 3; n++)
							printf("fisher %c :%d %d %d\n", 'A' + n, a[n][0], a[n][1], a[n][2]);
					}
				}
			}
		}


	}
	return 0;
}
```

