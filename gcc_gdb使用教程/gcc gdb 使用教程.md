# gcc gdb 使用教程

## gcc编译

|                    命令                     |                             用途                             |
| :-----------------------------------------: | :----------------------------------------------------------: |
|              gcc + filename.c               |                    编译生成**a.out**文件                     |
|         gcc -o filename filename.c          |        将**filename.c**编译生成**filename**可执行文件        |
| gcc -E filename.c -o filename.i(预处理阶段) |     将**filename.c**编译生成**filename.i**预处理后的文件     |
|  gcc -S filename.i -o filename.s(编译阶段)  |        将**filename.i**编译生成**filename.s**汇编文件        |
|  gcc -c filename.s -o filename.o(汇编阶段)  | 将汇编文件**filename.s**汇编成机器可以识别**filename.o**目标文件 |
|    gcc filename.o -o filename(链接阶段)     | 将多个目标代码模块链接生成一个大的目标模块输入的是**filename.o**输出的是**filename** |
|    gcc -pedantic filename.c -o filename     | gcc在编译不符合ANSI/ISO C语言标准的源代码时，加上-pedantic选项会产生警告 |
|                 gcc -Werror                 |                   将所有的警告当成错误处理                   |
|                                             |                                                              |

## gcc优化

**gcc**提供的代码优化功能十分强大，通过编译选项**-On**来控制优化代码的生成，其中**n**是一个代表优化级别的整数

|  命令   |                             用途                             |
| :-----: | :----------------------------------------------------------: |
| gcc -O  |                 同时减少代码的长度和执行时间                 |
| gcc -O1 |                       等价于**gcc -O**                       |
| gcc -O2 |            在**O1**的基础上进行一些额外的调整工作            |
| gcc -O3 | 在**O2**的基础山，完成包括循环展开和一些于处理器特性相关的优化工作 |

> `gcc -O filename.c -o filename`

## gcc调试选项

默认情况下，gcc在编译时不会将调试符号插入到生成的二进制代码中，如有需要编译时生成调试符号信息，可以使用**gcc**的**-g**或者是**-ggdb**选项

### gcc调试的分级

>|  命令   |                     用途                      |
>| :-----: | :-------------------------------------------: |
>| gcc -g  |               默认的的级别为g2                |
>| gcc -g1 |     不包含局部变量和与行号有关的调试信息      |
>| gcc -g2 | 包括扩展的符号表、行号、局部或者外部变量信息  |
>| gcc -g3 | 包括级别2的所有调试信息以及源代码中所定义的宏 |

==-ggdb方便gdb调试器调试，等级与-g的级别是相同的==

## gdb调试器

### 提供的功能

- 设置断点，使得程序在制定的代码行上停止执行，便于观察
- 单步执行程序，便于调试
- 查看程序中变量值的变化
- 动态改变程序的执行环境
- 分析崩溃程序产生的**core**文件

### 命令形式

> `gdb filename`

==为了使gdb正常工作，必须使程序在编译时包含调试信息，这需要在**gcc**编译的时候加上**-g**或者**-ggdb**选项==

### gdb常用命令

|   命令    |                           含义描述                           |
| :-------: | :----------------------------------------------------------: |
|   file    |                   装入想要调试的可执行文件                   |
|    run    |                     执行当前被调试的程序                     |
|   kill    |                      终止正在调试的程序                      |
|   step    |                执行一行源代码而且进入函数内部                |
|   next    |                执行一行源代码但不进入函数内部                |
|   break   |                       在代码中设置断点                       |
|   print   | 打印表达式或者变量的值，或者打印内存中某个变量开始的一段连续区域的值，还可以用来对变量进行赋值 |
|  display  | 设置自动显示的表达式或者变量，当程序停住或在单步跟踪时，这些变量会自动显示当前值 |
|   list    |                 列出产生执行文件源码的一部分                 |
|   quit    |                         退出**gdb**                          |
|   watch   |              监视一个变量的值，不管它何时被改变              |
| backtrace |                           回溯跟踪                           |
|  frame n  | 定位到发生错误的代码段，**n**为**backtrace**命令输出结果中的行号 |
|  examine  |                      查看内存地址中的值                      |
|   jump    |                        是程序跳转执行                        |
|  signal   |                          产生信号量                          |
|  return   |                         强制函数返回                         |
|   call    |                         强制调用函数                         |
|   make    |         使用户不退出**gdb**就可以重新产生可执行文件          |
|   shell   |    使用户不离开**gdb**就可以执行**Linux**的**shell**命令     |

### break命令的用法

|          命令           |                           含义描述                           |
| :---------------------: | :----------------------------------------------------------: |
|     break<function>     | 在进入制定函数时停住。C++可以使用**class::function**或者**function(type,type)**格式来指定函数名 |
|     break<linenum>      |                      在指定行号之前停住                      |
|     break + offset      |    在当前行号的前面的**offset**行停住。**offset**为自然数    |
|     break - offset      |    在当前行号的后面的**offset**行停住。**offset**为自然数    |
| break filename:linenum  |          在源文件**filename**的**linenum**行处停下           |
| break filename:function |      在源文件**filename**的**function**的函数入口处停下      |
|     break *address      |                  在程序运行的内存地址处停住                  |
|          break          |                      在下一条指令处停住                      |
|   break…if<condition>   | **condition**表示条件，在条件成立时停住。<br />**break if i=100**，表示在**i = 100**时停住程序 |
|                         |                                                              |

### 查看运行时的数据

#### print命令

> 命令格式：
>
> **print<expr>**
>
> **print /<f> <expr>**

其中<expr>是表达式，是所调试程序的语言的表达式；<f>是输出的格式，比如说要把表达式按16进制输出就是**/x**

#### 自动显示命令

> 命令格式
>
> **display <expr>**
>
> **display /<fmt> <expr>**
>
> **display /<fmt> <addr>**

**expr**是一个表达式，**fmt**表示显示的格式，**addr**表示内存地址。当用**display**设定好一个或多个表达式后，只要程序停下来，**gdb**就会自动显示所设置的表达式的值

|                        命令                        |                           含义描述                           |
| :------------------------------------------------: | :----------------------------------------------------------: |
|    undisplay<dnums><br />delete dispaly<dnums>     |      删除自动显示，dnums为已经设置好的自动显示的编号。       |
| disable display <dunms><br />enable dispaly<dnums> |           不删除自动显示的设置，只是让其失效或回复           |
|                    info display                    | 查看**display**设置的自动显示的信息，**gdb**会显示出一张表格，报告调试中设置了多少个自动显示设置 |

## gdb查看源程序

### 查看源代码

#### list命令

|         命令         |                 含义描述                  |
| :------------------: | :---------------------------------------: |
|  list <linenumber>   |    显示程序在**linenumber**附近的代码     |
|    list<function>    |  显示函数名为**function**的函数的源程序   |
|         list         |          显示当前行后面的源代码           |
|        list -        |   显示当前行前面的源代码，默认显示10行    |
| set listsize <count> |        设置一次显示的源代码的行数         |
|    show listsize     |        查看当前**listsize**的设置         |
| list <first> <last>  | 显示从**first**行到**last**行之间的源代码 |
|    list , <last>     |   显示从当前行到**last**行之间的源代码    |
|        list +        |              向后显示源代码               |

#### 查看源代码的内存

- **diaassemble**查看源程序的当前执行时的机器码
- 可以使用**info line**命令来查看源代码在内存中的地址

### 改变程序的执行

在**gdb**中可以根据自己的调试思路动态的在**gdb**中更改当前被调试程序的运行线路或是其中变量的值

#### 修改变量的值

**print**命令可以用来修改调试程序运行时变量的值

> ==(gdb) print x=8==

**x=8**是C/C++的语法，弱国调试的语言是Pascal，可以使用Pascal的语法**x:=8**

#### 跳转执行

**gdb**提供了乱序执行的功能，这个功能由**jump**命令实现

> ==jump <linespec>==

- 指定下一条语句的运行点。**<linespec>**可以是文件的行号，可以是**fine:line**格式。也可以是**+num**这种偏移量的格式

> ==jump <address>==

这里的**<address>**是代码运行时的内存地址

### 产生信号量

使用**signal**命令可以产生一个信号量给被调试的程序，如中断信号**Ctrl+C**。这非常方便程序的调试，可以在任意的位置设置断点，并在该断电用**gdb**产生一个信号量。

> ==signal<signal>==

* **Linux**的系统信号量通常是**1**到**15**，所以<signal>的取值就在这个范围内。
* 系统的**kill**命令是**gdb**截获的，而**signal**命令所发出的信号是直接发给被调试程序的

### 强制函数返回

* 如果调试断点在某个函数中，还有语句没有执行完成，可以使用**return**命令强制函数忽略还没有执行的语句并返回

* > ==return <expression>==

使用**return**命令取消当前函数的只看，并立即返回，如果制定了**<expression>**，那么该表达式的值会被当做函数的返回值

#### 强制调用函数

* 强制调用函数使用**call**命令

* > ==call <expr>==

* 表达式中可以是函数，从而达到强制调用函数的目的，显示函数的返回值，如果函数返回值是**void**，那么不显示
* **print**后面可以跟表达式，所以也可以用来调用函数。**print**和**call**不同的是，如果函数的返回值是**void**，**call**是不显示，**print**则是显示函数的返回值，并把该值存入历史数据中