## C内存管理

> 内存分配和管理函数可以在<stdlib.h>找到

| 序号 | 函数和描述                                                   |
| ---- | ------------------------------------------------------------ |
| 1    | `void *calloc(int num,int size)`<br />在内存中动态的分配**num**个长度为**size**的连续空间，并将每一个字节都初始化为0。所以他的结果是分配了**num*size**个字节长度的内存空间，并且每一个字节的值都是0 |
| 2    | `void free(void *address);`<br />该函数释放**address**所指向的内存快，释放的是动态分配的存储空间 |
| 3    | `void *malloc(int num)`<br />在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完之后不会被初始化，他们的值是未知的 |
| 4    | `void *realloc(void *adress,int newsize);`<br />该函数重新分配内存，把内存扩展到**newsize** |

==void *类型指的是未确定类型的指针。C和C++规定void *类型可以通过类型转换强制转换为任何其他类型的指针==

### 动态内存分配

#### 实例：

如果事先知道数组的大小，定义数组时可以很方便。

`char name[100];`

若事先不知道需要存储的文本长度，就可以定义一个指针，该指针指向未定义所需要内存的大小，而后按需分配内存

`memoryManger01.c`

#### 运行结果：

```
Name = Zara Ali
Description: Zara ali a DPS student in class 10th
```

#### 扩展

上面的程序也可以用**calloc()**来编写，只需要把**malloc** 替换为 **calloc** 即可

> ==`calloc (200,sizeof(char));`==

### 重新调整内存的大小和释放内存

当程序退出时，操作系统会自动释放所有分配给程序的内存。但是，在不需要内存的时候，仍然建议使用**free()**来增加或减少已经分配的内存的大小。

#### 实例

`memoryManger02.c`

#### 运行结果